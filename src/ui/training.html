<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Training Monitor</title>
  <style>
    :root {
      --bg: #f5ecd9;
      --panel: #fbf6eb;
      --panel-strong: #eee1ca;
      --ink: #3e3222;
      --ink-soft: #7b6a52;
      --accent: #ad7a46;
      --ok: #3f7c4a;
      --warn: #a67222;
      --bad: #ad4f4f;
      --border: rgba(126, 102, 67, 0.25);
      --mono: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: "Avenir Next", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(900px 360px at 0% -20%, rgba(182, 138, 87, 0.24), transparent),
        radial-gradient(900px 460px at 100% 0%, rgba(191, 167, 121, 0.24), transparent),
        var(--bg);
      min-height: 100vh;
    }

    .layout {
      max-width: 1220px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      box-shadow: 0 14px 26px rgba(73, 56, 33, 0.14);
    }

    .left {
      padding: 16px;
      position: sticky;
      top: 16px;
      align-self: start;
    }

    h1 {
      margin: 0 0 4px;
      font-size: 1.2rem;
    }

    .subtitle {
      margin: 0 0 12px;
      color: var(--ink-soft);
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .kv {
      margin-top: 12px;
      display: grid;
      grid-template-columns: 100px 1fr;
      gap: 8px;
      align-items: start;
      font-size: 0.83rem;
    }

    .kv-label {
      color: var(--ink-soft);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.72rem;
      padding-top: 2px;
    }

    .kv-value {
      font-family: var(--mono);
      word-break: break-word;
      line-height: 1.35;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    .chip {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 4px 10px;
      font-size: 0.73rem;
      color: var(--ink-soft);
      background: var(--panel-strong);
    }

    .chip.ok { color: var(--ok); border-color: rgba(63, 124, 74, 0.38); background: rgba(63, 124, 74, 0.1); }
    .chip.warn { color: var(--warn); border-color: rgba(166, 114, 34, 0.38); background: rgba(166, 114, 34, 0.1); }
    .chip.bad { color: var(--bad); border-color: rgba(173, 79, 79, 0.38); background: rgba(173, 79, 79, 0.1); }

    .progress-wrap {
      margin-top: 14px;
    }

    progress {
      width: 100%;
      height: 12px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: #ede0ca;
    }

    .controls {
      margin-top: 14px;
      display: grid;
      gap: 8px;
    }

    button {
      appearance: none;
      border: 0;
      border-radius: 9px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
      background: var(--accent);
      color: #fff9ef;
    }

    button.secondary {
      background: #8f7350;
    }

    .main {
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .dashboard {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #f8f1e3;
      padding: 10px;
      display: grid;
      gap: 10px;
    }

    .metric-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }

    .metric {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--panel);
      padding: 8px;
      min-height: 64px;
    }

    .metric-label {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--ink-soft);
      margin-bottom: 4px;
    }

    .metric-value {
      font-family: var(--mono);
      font-size: 0.9rem;
      color: var(--ink);
      word-break: break-word;
    }

    .chart-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(220px, 1fr));
      gap: 10px;
    }

    .chart-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--panel);
      padding: 8px;
    }

    .chart-title {
      margin: 0 0 6px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--ink-soft);
    }

    canvas {
      width: 100%;
      height: 180px;
      display: block;
      border-radius: 8px;
      background: #fff8ed;
      border: 1px solid rgba(126, 102, 67, 0.18);
    }

    .prompt-scoring {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #f8f1e3;
      padding: 10px;
    }

    .alerts {
      border: 1px solid rgba(166, 114, 34, 0.34);
      border-radius: 10px;
      background: #f6ecd8;
      padding: 10px;
    }

    .alerts-header {
      margin: 0;
      font-size: 0.88rem;
      color: var(--warn);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .alerts-empty {
      margin-top: 8px;
      font-size: 0.8rem;
      color: var(--ink-soft);
      font-family: var(--mono);
    }

    .alert-list {
      margin-top: 8px;
      display: grid;
      gap: 8px;
    }

    .alert-item {
      border: 1px solid rgba(166, 114, 34, 0.28);
      border-left: 4px solid var(--warn);
      border-radius: 8px;
      background: #fbf4e6;
      padding: 8px;
    }

    .alert-title {
      font-size: 0.8rem;
      font-weight: 700;
      color: var(--warn);
      margin-bottom: 4px;
    }

    .alert-body {
      font-size: 0.78rem;
      color: var(--ink);
      line-height: 1.4;
      font-family: var(--mono);
    }

    .prompt-scoring-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .prompt-scoring-title {
      margin: 0;
      font-size: 0.88rem;
    }

    .prompt-scoring-sub {
      font-size: 0.78rem;
      color: var(--ink-soft);
      font-family: var(--mono);
    }

    .score-table-wrap {
      max-height: 220px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--panel);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }

    thead th {
      position: sticky;
      top: 0;
      background: var(--panel-strong);
      z-index: 1;
      text-align: left;
      padding: 7px 8px;
      border-bottom: 1px solid var(--border);
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    tbody td {
      padding: 7px 8px;
      border-bottom: 1px solid rgba(126, 102, 67, 0.18);
      font-family: var(--mono);
      vertical-align: top;
    }

    tbody tr:last-child td {
      border-bottom: 0;
    }

    .delta-pos {
      color: var(--ok);
      font-weight: 700;
    }

    .delta-neg {
      color: var(--bad);
      font-weight: 700;
    }

    .decision-ok {
      color: var(--ok);
      font-weight: 700;
    }

    .decision-no {
      color: var(--warn);
      font-weight: 700;
    }

    .events {
      max-height: 46vh;
      overflow: auto;
      padding-right: 2px;
    }

    .event {
      margin-top: 8px;
      border: 1px solid var(--border);
      border-left: 4px solid var(--accent);
      border-radius: 10px;
      overflow: hidden;
      background: #f7efdf;
    }

    .event.warn { border-left-color: var(--warn); }
    .event.bad { border-left-color: var(--bad); }

    .event-head {
      padding: 9px 10px;
      background: var(--panel-strong);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.78rem;
      font-family: var(--mono);
    }

    .event-body {
      padding: 10px;
      font-size: 0.82rem;
      line-height: 1.4;
      color: var(--ink);
    }

    .event-body pre {
      margin: 8px 0 0;
      font-size: 0.76rem;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      color: var(--ink-soft);
    }

    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
      .left { position: static; }
      .metric-row { grid-template-columns: repeat(2, minmax(110px, 1fr)); }
      .chart-grid { grid-template-columns: 1fr; }
      .events { max-height: 50vh; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <section class="panel left">
      <h1>Training Monitor</h1>
      <p class="subtitle">Live tracker for prompt A/B training. Keep this page open while running `thinking train`.</p>

      <div class="chips">
        <span class="chip" id="state-chip">state: idle</span>
        <span class="chip" id="events-chip">events: 0</span>
        <span class="chip" id="eta-chip">eta: --</span>
        <span class="chip" id="alerts-chip">alerts: 0</span>
      </div>

      <div class="progress-wrap">
        <progress id="epoch-progress" max="1" value="0"></progress>
      </div>

      <div class="kv"><div class="kv-label">Run ID</div><div class="kv-value" id="run-id">--</div></div>
      <div class="kv"><div class="kv-label">Epoch</div><div class="kv-value" id="epoch">0 / 0</div></div>
      <div class="kv"><div class="kv-label">Phase</div><div class="kv-value" id="phase">idle</div></div>
      <div class="kv"><div class="kv-label">Step</div><div class="kv-value" id="step">idle</div></div>
      <div class="kv"><div class="kv-label">Message</div><div class="kv-value" id="message">No activity yet.</div></div>
      <div class="kv"><div class="kv-label">Case</div><div class="kv-value" id="case">--</div></div>
      <div class="kv"><div class="kv-label">Run ETA</div><div class="kv-value" id="eta-run">--</div></div>
      <div class="kv"><div class="kv-label">Phase ETA</div><div class="kv-value" id="eta-phase">--</div></div>
      <div class="kv"><div class="kv-label">Case ETA</div><div class="kv-value" id="eta-case">--</div></div>
      <div class="kv"><div class="kv-label">Updated</div><div class="kv-value" id="updated">--</div></div>
      <div class="kv"><div class="kv-label">Status File</div><div class="kv-value" id="status-file">--</div></div>
      <div class="kv"><div class="kv-label">Events File</div><div class="kv-value" id="events-file">--</div></div>
      <div class="kv"><div class="kv-label">Log File</div><div class="kv-value" id="log-file">--</div></div>

      <div class="controls">
        <button id="reconnect-btn">Reconnect Stream</button>
        <button class="secondary" id="refresh-btn">Refresh Status</button>
        <button class="secondary" id="clear-btn">Clear Event View</button>
      </div>
    </section>

    <section class="panel main">
      <section class="dashboard">
        <div class="metric-row">
          <div class="metric"><div class="metric-label">Avg Score A</div><div class="metric-value" id="metric-avg-a">0.00</div></div>
          <div class="metric"><div class="metric-label">Avg Score B</div><div class="metric-value" id="metric-avg-b">0.00</div></div>
          <div class="metric"><div class="metric-label">Delta</div><div class="metric-value" id="metric-delta">0.00</div></div>
          <div class="metric"><div class="metric-label">Latest Case</div><div class="metric-value" id="metric-case">--</div></div>
          <div class="metric"><div class="metric-label">Failures</div><div class="metric-value" id="metric-failures">0</div></div>
          <div class="metric"><div class="metric-label">RCA Items</div><div class="metric-value" id="metric-rca">0</div></div>
          <div class="metric"><div class="metric-label">Elapsed (s)</div><div class="metric-value" id="metric-elapsed">0.0</div></div>
          <div class="metric"><div class="metric-label">Phase Elapsed (s)</div><div class="metric-value" id="metric-phase-elapsed">0.0</div></div>
          <div class="metric"><div class="metric-label">Avg Case (s)</div><div class="metric-value" id="metric-avg-case">--</div></div>
          <div class="metric"><div class="metric-label">P90 Case (s)</div><div class="metric-value" id="metric-p90-case">--</div></div>
          <div class="metric"><div class="metric-label">Cases / Min</div><div class="metric-value" id="metric-throughput">--</div></div>
        </div>

        <div class="chart-grid">
          <div class="chart-card">
            <p class="chart-title">Epoch Scores (A vs B)</p>
            <canvas id="scores-chart" width="420" height="180"></canvas>
          </div>
          <div class="chart-card">
            <p class="chart-title">Failures and RCA Volume</p>
            <canvas id="failures-chart" width="420" height="180"></canvas>
          </div>
          <div class="chart-card">
            <p class="chart-title">Prompt Score Decisions</p>
            <canvas id="prompt-chart" width="420" height="180"></canvas>
          </div>
          <div class="chart-card">
            <p class="chart-title">Case Runtime (Pipeline vs Grading)</p>
            <canvas id="runtime-chart" width="420" height="180"></canvas>
          </div>
        </div>
      </section>

      <section class="alerts">
        <h3 class="alerts-header">Intervention Warnings</h3>
        <div class="alerts-empty" id="alerts-empty">No active timing alerts.</div>
        <div class="alert-list" id="alerts-list"></div>
      </section>

      <section class="prompt-scoring">
        <div class="prompt-scoring-header">
          <h3 class="prompt-scoring-title">Timing Diagnostics</h3>
          <span class="prompt-scoring-sub" id="timing-sub">No timing diagnostics yet.</span>
        </div>
        <div class="score-table-wrap">
          <table>
            <thead>
              <tr>
                <th>Phase</th>
                <th>Samples</th>
                <th>Avg (s)</th>
                <th>P90 (s)</th>
                <th>Latest (s)</th>
              </tr>
            </thead>
            <tbody id="phase-stats-body"></tbody>
          </table>
        </div>
      </section>

      <section class="prompt-scoring">
        <div class="prompt-scoring-header">
          <h3 class="prompt-scoring-title">Prompt Scoring Diagnostics</h3>
          <span class="prompt-scoring-sub" id="prompt-scoring-sub">No prompt scoring data yet.</span>
        </div>
        <div class="score-table-wrap">
          <table>
            <thead>
              <tr>
                <th>Block</th>
                <th>Baseline</th>
                <th>Candidate</th>
                <th>Delta</th>
                <th>Accepted</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody id="prompt-score-body"></tbody>
          </table>
        </div>
      </section>

      <div class="events" id="events"></div>
    </section>
  </div>

  <script>
    const stateChip = document.getElementById('state-chip');
    const eventsChip = document.getElementById('events-chip');
    const etaChip = document.getElementById('eta-chip');
    const alertsChip = document.getElementById('alerts-chip');
    const epochProgress = document.getElementById('epoch-progress');
    const runIdEl = document.getElementById('run-id');
    const epochEl = document.getElementById('epoch');
    const phaseEl = document.getElementById('phase');
    const stepEl = document.getElementById('step');
    const messageEl = document.getElementById('message');
    const caseEl = document.getElementById('case');
    const etaRunEl = document.getElementById('eta-run');
    const etaPhaseEl = document.getElementById('eta-phase');
    const etaCaseEl = document.getElementById('eta-case');
    const updatedEl = document.getElementById('updated');
    const statusFileEl = document.getElementById('status-file');
    const eventsFileEl = document.getElementById('events-file');
    const logFileEl = document.getElementById('log-file');
    const eventsEl = document.getElementById('events');
    const alertsEmptyEl = document.getElementById('alerts-empty');
    const alertsListEl = document.getElementById('alerts-list');

    const metricAvgAEl = document.getElementById('metric-avg-a');
    const metricAvgBEl = document.getElementById('metric-avg-b');
    const metricDeltaEl = document.getElementById('metric-delta');
    const metricCaseEl = document.getElementById('metric-case');
    const metricFailuresEl = document.getElementById('metric-failures');
    const metricRcaEl = document.getElementById('metric-rca');
    const metricElapsedEl = document.getElementById('metric-elapsed');
    const metricPhaseElapsedEl = document.getElementById('metric-phase-elapsed');
    const metricAvgCaseEl = document.getElementById('metric-avg-case');
    const metricP90CaseEl = document.getElementById('metric-p90-case');
    const metricThroughputEl = document.getElementById('metric-throughput');

    const promptScoringSubEl = document.getElementById('prompt-scoring-sub');
    const promptScoreBodyEl = document.getElementById('prompt-score-body');
    const timingSubEl = document.getElementById('timing-sub');
    const phaseStatsBodyEl = document.getElementById('phase-stats-body');
    const scoresChart = document.getElementById('scores-chart');
    const failuresChart = document.getElementById('failures-chart');
    const promptChart = document.getElementById('prompt-chart');
    const runtimeChart = document.getElementById('runtime-chart');

    const reconnectBtn = document.getElementById('reconnect-btn');
    const refreshBtn = document.getElementById('refresh-btn');
    const clearBtn = document.getElementById('clear-btn');

    let source = null;
    let eventCount = 0;
    const MAX_PAYLOAD_CHARS = 6000;
    const MAX_RENDERED_EVENTS = 800;
    const MAX_STATS_POINTS = 240;
    const INTERVENTION_SECONDS = 10 * 60;
    const seenEventKeys = new Set();

    const trend = {
      scoresA: [],
      scoresB: [],
      deltas: [],
      failures: [],
      rca: [],
      promptAccepted: [],
      promptRejected: [],
      promptScored: [],
      runtimePipeline: [],
      runtimeGrading: [],
      runtimeCase: [],
      latestPromptScores: [],
      latestPromptEpoch: 0,
    };

    const diagnostics = {
      latestTracking: {},
      lastEventTsMs: 0,
      lastCaseStartedTsMs: null,
      lastEventsCount: 0,
      lastEventsCountChangeTsMs: Date.now(),
      caseDurationsSec: [],
      pipelineDurationsSec: [],
      gradingDurationsSec: [],
      phaseCaseDurationsByPhase: {},
      phaseDurationsByPhase: {},
      phaseLatestByPhase: {},
      phaseCaseTotalsByEpoch: {},
      epochCompletedDurationsSec: [],
      lastEpochCompletedElapsedSec: 0,
      latestWarnings: [],
    };

    function pushCapped(list, value, maxLen = MAX_STATS_POINTS) {
      if (!Number.isFinite(Number(value))) return;
      list.push(Number(value));
      if (list.length > maxLen) list.shift();
    }

    function toNum(value, fallback = 0) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : fallback;
    }

    function safeFixed(value, digits = 2) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed.toFixed(digits) : '--';
    }

    function parseTimestampMs(value) {
      if (typeof value === 'number' && Number.isFinite(value)) {
        return value > 1e12 ? value : value * 1000;
      }
      if (typeof value === 'string' && value.trim()) {
        const parsed = Date.parse(value);
        if (Number.isFinite(parsed)) return parsed;
      }
      return 0;
    }

    function mean(values) {
      if (!Array.isArray(values) || !values.length) return null;
      return values.reduce((sum, item) => sum + Number(item || 0), 0) / values.length;
    }

    function percentile(values, p) {
      if (!Array.isArray(values) || !values.length) return null;
      const sorted = values
        .map((v) => Number(v))
        .filter((v) => Number.isFinite(v))
        .sort((a, b) => a - b);
      if (!sorted.length) return null;
      const rank = Math.min(sorted.length - 1, Math.max(0, Math.ceil((p / 100) * sorted.length) - 1));
      return sorted[rank];
    }

    function formatDuration(seconds) {
      const total = Number(seconds);
      if (!Number.isFinite(total) || total < 0) return '--';
      const rounded = Math.round(total);
      const h = Math.floor(rounded / 3600);
      const m = Math.floor((rounded % 3600) / 60);
      const s = rounded % 60;
      if (h > 0) return `${h}h ${m}m ${s}s`;
      if (m > 0) return `${m}m ${s}s`;
      return `${s}s`;
    }

    function ensureEpochSlot(epoch) {
      const idx = Math.max(0, Number(epoch || 1) - 1);
      const arrays = [
        trend.scoresA,
        trend.scoresB,
        trend.deltas,
        trend.failures,
        trend.rca,
        trend.promptAccepted,
        trend.promptRejected,
        trend.promptScored,
      ];
      for (const arr of arrays) {
        while (arr.length <= idx) arr.push(null);
      }
      return idx;
    }

    function resetDiagnosticsState() {
      diagnostics.latestTracking = {};
      diagnostics.lastEventTsMs = 0;
      diagnostics.lastCaseStartedTsMs = null;
      diagnostics.lastEventsCount = 0;
      diagnostics.lastEventsCountChangeTsMs = Date.now();
      diagnostics.caseDurationsSec = [];
      diagnostics.pipelineDurationsSec = [];
      diagnostics.gradingDurationsSec = [];
      diagnostics.phaseCaseDurationsByPhase = {};
      diagnostics.phaseDurationsByPhase = {};
      diagnostics.phaseLatestByPhase = {};
      diagnostics.phaseCaseTotalsByEpoch = {};
      diagnostics.epochCompletedDurationsSec = [];
      diagnostics.lastEpochCompletedElapsedSec = 0;
      diagnostics.latestWarnings = [];
      etaRunEl.textContent = '--';
      etaPhaseEl.textContent = '--';
      etaCaseEl.textContent = '--';
      etaChip.textContent = 'eta: --';
      timingSubEl.textContent = 'No timing diagnostics yet.';
      renderPhaseStatsTable();
      renderWarnings([]);
    }

    function resetTrendState() {
      trend.scoresA = [];
      trend.scoresB = [];
      trend.deltas = [];
      trend.failures = [];
      trend.rca = [];
      trend.promptAccepted = [];
      trend.promptRejected = [];
      trend.promptScored = [];
      trend.runtimePipeline = [];
      trend.runtimeGrading = [];
      trend.runtimeCase = [];
      trend.latestPromptScores = [];
      trend.latestPromptEpoch = 0;
      promptScoringSubEl.textContent = 'No prompt scoring data yet.';
      renderPromptScoreTable([]);
      resetDiagnosticsState();
      drawAllCharts();
    }

    function setStateChip(state) {
      const normalized = String(state || 'idle').toLowerCase();
      stateChip.textContent = `state: ${normalized}`;
      stateChip.className = 'chip';
      if (normalized === 'running' || normalized === 'completed') stateChip.classList.add('ok');
      else if (normalized === 'error') stateChip.classList.add('bad');
      else stateChip.classList.add('warn');
    }

    function setAlertsChip(warnings) {
      const items = Array.isArray(warnings) ? warnings : [];
      alertsChip.className = 'chip';
      alertsChip.textContent = `alerts: ${items.length}`;
      if (!items.length) return;
      const hasBad = items.some((item) => item.severity === 'bad');
      alertsChip.classList.add(hasBad ? 'bad' : 'warn');
    }

    function eventClass(eventType) {
      const et = String(eventType || '').toLowerCase();
      if (et.includes('error') || et.includes('failed')) return 'bad';
      if (et.includes('warning') || et.includes('reject')) return 'warn';
      return '';
    }

    function createEventNode(event) {
      const article = document.createElement('article');
      article.className = `event ${eventClass(event.event_type)}`.trim();

      const head = document.createElement('div');
      head.className = 'event-head';
      head.innerHTML = `
        <span>${event.timestamp || '--'} | ${event.event_type || 'event'}</span>
        <span>epoch ${event.epoch_current || 0}/${event.epochs_total || 0} | ${event.phase || ''} / ${event.step || ''}</span>
      `;

      const body = document.createElement('div');
      body.className = 'event-body';
      const message = event.message || '';
      let payload = '';
      if (event.payload && Object.keys(event.payload).length) {
        let payloadText = JSON.stringify(event.payload, null, 2);
        if (payloadText.length > MAX_PAYLOAD_CHARS) {
          payloadText = `${payloadText.slice(0, MAX_PAYLOAD_CHARS)}\n... [payload truncated for UI performance]`;
        }
        payload = `<pre>${payloadText}</pre>`;
      }
      body.innerHTML = `${message}${payload}`;

      article.appendChild(head);
      article.appendChild(body);
      return article;
    }

    function appendEvent(event) {
      eventCount += 1;
      eventsChip.textContent = `events: ${eventCount}`;
      eventsEl.appendChild(createEventNode(event));
      eventsEl.scrollTop = eventsEl.scrollHeight;
      while (eventsEl.children.length > MAX_RENDERED_EVENTS) {
        eventsEl.removeChild(eventsEl.firstChild);
      }
    }

    function eventKey(event) {
      const runId = event.run_id || 'no-run';
      if (event.seq !== undefined && event.seq !== null) {
        return `${runId}:seq:${event.seq}`;
      }
      return `${runId}:${event.timestamp || ''}:${event.event_type || ''}:${event.phase || ''}:${event.step || ''}`;
    }

    function recordCaseTotalForEpoch(event) {
      const epoch = Number(event.epoch_current || 0);
      const phase = String(event.phase || '');
      const total = toNum(event?.current_case?.total, 0);
      if (!epoch || !phase || !total) return;
      if (!diagnostics.phaseCaseTotalsByEpoch[epoch]) diagnostics.phaseCaseTotalsByEpoch[epoch] = {};
      diagnostics.phaseCaseTotalsByEpoch[epoch][phase] = total;
    }

    function estimateCasesPerEpoch(tracking = {}) {
      const observed = [];
      for (const key of Object.keys(diagnostics.phaseCaseTotalsByEpoch)) {
        const byPhase = diagnostics.phaseCaseTotalsByEpoch[key] || {};
        const total = Object.values(byPhase).reduce((sum, item) => sum + toNum(item, 0), 0);
        if (total > 0) observed.push(total);
      }
      const observedAvg = mean(observed);
      if (observedAvg && observedAvg > 0) return observedAvg;
      const currentTotal = toNum(tracking?.current_case?.total, 0);
      if (currentTotal > 0) return currentTotal * 2;
      return null;
    }

    function estimateCasesForPhase(phase, tracking = {}) {
      const phaseName = String(phase || '');
      if (!phaseName) return null;
      const observed = [];
      for (const key of Object.keys(diagnostics.phaseCaseTotalsByEpoch)) {
        const byPhase = diagnostics.phaseCaseTotalsByEpoch[key] || {};
        const total = toNum(byPhase[phaseName], 0);
        if (total > 0) observed.push(total);
      }
      const observedAvg = mean(observed);
      if (observedAvg && observedAvg > 0) return observedAvg;

      const currentPhase = String(tracking.phase || '');
      const currentTotal = toNum(tracking?.current_case?.total, 0);
      if (currentPhase === phaseName && currentTotal > 0) return currentTotal;
      return null;
    }

    function blendEta(primary, fallback, primaryWeight = 0.7) {
      const p = Number(primary);
      const f = Number(fallback);
      const hasP = Number.isFinite(p) && p >= 0;
      const hasF = Number.isFinite(f) && f >= 0;
      if (hasP && hasF) return (p * primaryWeight) + (f * (1 - primaryWeight));
      if (hasP) return p;
      if (hasF) return f;
      return null;
    }

    function estimateRunEtaFromEpochs(tracking = {}, elapsedSec = 0) {
      const running = String(tracking.state || '').toLowerCase() === 'running';
      const epochCurrent = toNum(tracking.epoch_current, 0);
      const epochsTotal = toNum(tracking.epochs_total, 0);
      const avgEpochSec = mean(diagnostics.epochCompletedDurationsSec);
      if (!running || !avgEpochSec || epochCurrent <= 0 || epochsTotal <= 0) {
        return {
          runEtaSec: null,
          avgEpochSec: avgEpochSec || null,
          currentEpochElapsedSec: null,
        };
      }

      const elapsedAtEpochBoundary = toNum(diagnostics.lastEpochCompletedElapsedSec, 0);
      const currentEpochElapsedSec = Math.max(0, elapsedSec - elapsedAtEpochBoundary);
      const currentEpochRemainingSec = Math.max(0, avgEpochSec - currentEpochElapsedSec);
      const remainingAfterCurrent = Math.max(epochsTotal - epochCurrent, 0);
      const runEtaSec = currentEpochRemainingSec + (remainingAfterCurrent * avgEpochSec);
      return {
        runEtaSec,
        avgEpochSec,
        currentEpochElapsedSec,
      };
    }

    function computeTimingSnapshot(tracking = {}) {
      const nowMs = Date.now();
      const running = String(tracking.state || '').toLowerCase() === 'running';
      const elapsedSec = toNum(tracking.elapsed_seconds, 0);
      const phaseElapsedSec = toNum(tracking.phase_elapsed_seconds, 0);
      const caseAvgSec = mean(diagnostics.caseDurationsSec);
      const caseP90Sec = percentile(diagnostics.caseDurationsSec, 90);
      const throughputCasesPerMin = elapsedSec > 0
        ? (diagnostics.caseDurationsSec.length / elapsedSec) * 60
        : null;

      const phase = String(tracking.phase || 'idle');
      const phaseHistory = diagnostics.phaseDurationsByPhase[phase] || [];
      const phaseAvgSec = mean(phaseHistory);
      const phaseCaseAvgSec = mean(diagnostics.phaseCaseDurationsByPhase[phase] || []) || caseAvgSec;
      const estimatedPhaseCaseTotal = estimateCasesForPhase(phase, tracking);
      const currentCaseIdx = toNum(tracking?.current_case?.index, 0);
      const currentCaseTotalRaw = toNum(tracking?.current_case?.total, 0);
      const currentCaseTotal = currentCaseTotalRaw > 0 ? currentCaseTotalRaw : toNum(estimatedPhaseCaseTotal, 0);
      const inProgressCaseCount = diagnostics.lastCaseStartedTsMs ? 1 : 0;
      const remainingCasesInPhase = currentCaseTotal > 0
        ? Math.max(currentCaseTotal - currentCaseIdx, 0) + inProgressCaseCount
        : null;

      const epochCurrent = toNum(tracking.epoch_current, 0);
      const epochsTotal = toNum(tracking.epochs_total, 0);
      const epochModel = estimateRunEtaFromEpochs(tracking, elapsedSec);
      let runEtaByCasesSec = null;
      if (running && caseAvgSec) {
        const expectedCasesPerEpoch = estimateCasesPerEpoch(tracking);
        if (expectedCasesPerEpoch && epochsTotal > 0) {
          const completedEpochs = Math.max(epochCurrent - 1, 0);
          const estimatedCasesFinishedBeforeCurrent = completedEpochs * expectedCasesPerEpoch;
          const estimatedCasesDoneInCurrent = Math.max(
            diagnostics.caseDurationsSec.length - estimatedCasesFinishedBeforeCurrent,
            0,
          );
          const fallbackRemainingCurrent = Math.max(expectedCasesPerEpoch - estimatedCasesDoneInCurrent, 0);
          const remainingCurrent = remainingCasesInPhase !== null
            ? Math.min(remainingCasesInPhase, expectedCasesPerEpoch)
            : fallbackRemainingCurrent;
          const remainingEpochsAfterCurrent = Math.max(epochsTotal - epochCurrent, 0);
          const remainingCases = remainingCurrent + (remainingEpochsAfterCurrent * expectedCasesPerEpoch);
          runEtaByCasesSec = Math.max(0, remainingCases * caseAvgSec);
        }
      }
      const epochModelWeight = diagnostics.epochCompletedDurationsSec.length >= 2 ? 0.85 : 0.65;
      const runEtaSec = blendEta(epochModel.runEtaSec, runEtaByCasesSec, epochModelWeight);

      const phaseEtaFromHistory = running && phaseAvgSec
        ? Math.max(phaseAvgSec - phaseElapsedSec, 0)
        : null;
      const phaseEtaFromCaseProgress = running && phaseCaseAvgSec && remainingCasesInPhase !== null
        ? Math.max(0, remainingCasesInPhase * phaseCaseAvgSec)
        : null;
      const phaseEtaSec = blendEta(phaseEtaFromCaseProgress, phaseEtaFromHistory, 0.7);

      const caseEtaSec = phaseEtaFromCaseProgress;

      const lastEventGapSec = diagnostics.lastEventTsMs > 0
        ? (nowMs - diagnostics.lastEventTsMs) / 1000
        : null;
      const eventCountGapSec = (nowMs - diagnostics.lastEventsCountChangeTsMs) / 1000;
      const activeCaseSec = diagnostics.lastCaseStartedTsMs
        ? (nowMs - diagnostics.lastCaseStartedTsMs) / 1000
        : null;

      return {
        runEtaSec,
        phaseEtaSec,
        caseEtaSec,
        caseAvgSec,
        caseP90Sec,
        throughputCasesPerMin,
        phaseCaseAvgSec,
        phaseAvgSec,
        epochAvgSec: epochModel.avgEpochSec || null,
        epochCurrentElapsedSec: epochModel.currentEpochElapsedSec || null,
        runEtaModelEpochSec: epochModel.runEtaSec || null,
        runEtaModelCasesSec: runEtaByCasesSec,
        phaseElapsedSec,
        remainingCasesInPhase,
        activeCaseSec,
        lastEventGapSec,
        eventCountGapSec,
      };
    }

    function buildWarnings(tracking = {}, snapshot = {}) {
      const warnings = [];
      const running = String(tracking.state || '').toLowerCase() === 'running';
      if (!running) return warnings;

      if (snapshot.lastEventGapSec !== null && snapshot.lastEventGapSec > INTERVENTION_SECONDS) {
        warnings.push({
          severity: 'bad',
          title: `No new training events for ${formatDuration(snapshot.lastEventGapSec)}`,
          detail: 'No-event timeout exceeded (10 minutes). Inspect logs/prompt_training.log and logs/pipeline.log for retries or blocked tool calls before continuing.',
        });
      }

      if (snapshot.eventCountGapSec > INTERVENTION_SECONDS) {
        warnings.push({
          severity: 'warn',
          title: `Event counter unchanged for ${formatDuration(snapshot.eventCountGapSec)}`,
          detail: 'Intervention threshold exceeded (10 minutes). Training may be waiting on a long model call. If this persists, lower prompt size or reduce case complexity.',
        });
      }

      if (snapshot.activeCaseSec !== null && snapshot.caseAvgSec) {
        const thresholdSec = Math.max(INTERVENTION_SECONDS, snapshot.caseAvgSec * 3);
        if (snapshot.activeCaseSec > thresholdSec) {
          warnings.push({
            severity: 'bad',
            title: `Current case runtime is unusually high (${formatDuration(snapshot.activeCaseSec)})`,
            detail: `Observed average case runtime is ~${safeFixed(snapshot.caseAvgSec, 1)}s. Intervention threshold is 10 minutes. Check for repeated schema retries or oversized prompts.`,
          });
        }
      }

      if (snapshot.phaseAvgSec) {
        const phaseThresholdSec = Math.max(INTERVENTION_SECONDS, snapshot.phaseAvgSec * 2.5);
        if (snapshot.phaseElapsedSec > phaseThresholdSec) {
          warnings.push({
            severity: 'warn',
            title: `Phase is running longer than baseline (${safeFixed(snapshot.phaseElapsedSec, 1)}s)`,
            detail: `Average for phase ${tracking.phase || 'current'} is ~${safeFixed(snapshot.phaseAvgSec, 1)}s. Intervention threshold is 10 minutes.`,
          });
        }
      }

      if (snapshot.runEtaSec && snapshot.runEtaSec > 3 * 3600) {
        warnings.push({
          severity: 'warn',
          title: `Estimated remaining time is high (${formatDuration(snapshot.runEtaSec)})`,
          detail: 'To speed up, reduce epochs, reduce sampled cases per epoch, or tighten token budgets for RCA blocks.',
        });
      }

      return warnings;
    }

    function renderWarnings(warnings) {
      const list = Array.isArray(warnings) ? warnings : [];
      diagnostics.latestWarnings = list;
      setAlertsChip(list);
      alertsListEl.innerHTML = '';
      if (!list.length) {
        alertsEmptyEl.style.display = 'block';
        alertsEmptyEl.textContent = 'No active timing alerts.';
        return;
      }
      alertsEmptyEl.style.display = 'none';
      const fragment = document.createDocumentFragment();
      for (const item of list) {
        const wrapper = document.createElement('div');
        wrapper.className = 'alert-item';
        if (item.severity === 'bad') {
          wrapper.style.borderLeftColor = 'var(--bad)';
          wrapper.style.borderColor = 'rgba(173, 79, 79, 0.34)';
        }
        const title = document.createElement('div');
        title.className = 'alert-title';
        title.textContent = item.title || 'Warning';
        if (item.severity === 'bad') title.style.color = 'var(--bad)';
        const body = document.createElement('div');
        body.className = 'alert-body';
        body.textContent = item.detail || '';
        wrapper.appendChild(title);
        wrapper.appendChild(body);
        fragment.appendChild(wrapper);
      }
      alertsListEl.appendChild(fragment);
    }

    function updateMetricCards(metrics = {}, tracking = {}, snapshot = {}) {
      metricAvgAEl.textContent = safeFixed(metrics.avg_score_a, 3);
      metricAvgBEl.textContent = safeFixed(metrics.avg_score_b, 3);
      metricDeltaEl.textContent = safeFixed(metrics.improvement_delta, 3);
      metricCaseEl.textContent = metrics.latest_case_score === undefined ? '--' : safeFixed(metrics.latest_case_score, 3);
      metricFailuresEl.textContent = String(toNum(metrics.num_failures_in_a, 0));
      metricRcaEl.textContent = String(toNum(metrics.num_rca_items, 0));
      metricElapsedEl.textContent = safeFixed(tracking.elapsed_seconds, 1);
      metricPhaseElapsedEl.textContent = safeFixed(tracking.phase_elapsed_seconds, 1);
      metricAvgCaseEl.textContent = snapshot.caseAvgSec ? safeFixed(snapshot.caseAvgSec, 2) : '--';
      metricP90CaseEl.textContent = snapshot.caseP90Sec ? safeFixed(snapshot.caseP90Sec, 2) : '--';
      metricThroughputEl.textContent = snapshot.throughputCasesPerMin
        ? safeFixed(snapshot.throughputCasesPerMin, 2)
        : '--';
    }

    function renderPhaseStatsTable() {
      phaseStatsBodyEl.innerHTML = '';
      const phaseNames = Object.keys(diagnostics.phaseDurationsByPhase).sort();
      if (!phaseNames.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.textContent = 'No phase timing diagnostics yet.';
        tr.appendChild(td);
        phaseStatsBodyEl.appendChild(tr);
        return;
      }

      for (const phase of phaseNames) {
        const samples = diagnostics.phaseDurationsByPhase[phase] || [];
        const avg = mean(samples);
        const p90 = percentile(samples, 90);
        const latest = diagnostics.phaseLatestByPhase[phase];
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${phase}</td>
          <td>${samples.length}</td>
          <td>${avg ? safeFixed(avg, 2) : '--'}</td>
          <td>${p90 ? safeFixed(p90, 2) : '--'}</td>
          <td>${latest ? safeFixed(latest, 2) : '--'}</td>
        `;
        phaseStatsBodyEl.appendChild(tr);
      }
    }

    function refreshDiagnostics() {
      const tracking = diagnostics.latestTracking || {};
      const snapshot = computeTimingSnapshot(tracking);
      etaRunEl.textContent = formatDuration(snapshot.runEtaSec);
      etaPhaseEl.textContent = formatDuration(snapshot.phaseEtaSec);
      etaCaseEl.textContent = formatDuration(snapshot.caseEtaSec);
      etaChip.textContent = `eta: ${formatDuration(snapshot.runEtaSec)}`;
      updateMetricCards(tracking.metrics || {}, tracking, snapshot);
      renderPhaseStatsTable();

      const epochAvgText = snapshot.epochAvgSec ? `${safeFixed(snapshot.epochAvgSec, 1)}s` : '--';
      const modelEpochText = snapshot.runEtaModelEpochSec ? formatDuration(snapshot.runEtaModelEpochSec) : '--';
      const modelCaseText = snapshot.runEtaModelCasesSec ? formatDuration(snapshot.runEtaModelCasesSec) : '--';
      timingSubEl.textContent = `cases ${diagnostics.caseDurationsSec.length} | avg ${snapshot.caseAvgSec ? `${safeFixed(snapshot.caseAvgSec, 2)}s` : '--'} | p90 ${snapshot.caseP90Sec ? `${safeFixed(snapshot.caseP90Sec, 2)}s` : '--'} | epoch avg ${epochAvgText} | eta(epoch/case) ${modelEpochText}/${modelCaseText}`;
      const warnings = buildWarnings(tracking, snapshot);
      renderWarnings(warnings);
    }

    function normalizeUpdatedAt(value) {
      if (typeof value === 'number' && Number.isFinite(value)) {
        const ms = value > 1e12 ? value : value * 1000;
        return new Date(ms).toISOString();
      }
      if (typeof value === 'string' && value.trim()) return value;
      return '--';
    }

    function renderStatus(status) {
      const root = status || {};
      const tracking = root?.tracking || root || {};
      const paths = tracking.paths || {};
      const metrics = tracking.metrics || {};
      const nowMs = Date.now();

      setStateChip(tracking.state || 'idle');
      runIdEl.textContent = tracking.run_id || '--';
      const current = Number(tracking.epoch_current || 0);
      const total = Number(tracking.epochs_total || 0);
      epochEl.textContent = `${current} / ${total}`;
      epochProgress.max = Math.max(total, 1);
      epochProgress.value = Math.min(current, epochProgress.max);
      phaseEl.textContent = tracking.phase || 'idle';
      stepEl.textContent = tracking.step || 'idle';
      messageEl.textContent = tracking.message || 'No activity yet.';
      const currentCase = tracking.current_case || null;
      if (currentCase && typeof currentCase === 'object') {
        const idx = currentCase.index ?? '--';
        const ctotal = currentCase.total ?? '--';
        const preview = currentCase.prompt_preview ? ` | ${currentCase.prompt_preview}` : '';
        caseEl.textContent = `${idx}/${ctotal}${preview}`;
      } else {
        caseEl.textContent = '--';
      }
      updatedEl.textContent = normalizeUpdatedAt(tracking.updated_at);

      const nextEventCount = Number(tracking.events_count || eventCount || 0);
      if (nextEventCount !== diagnostics.lastEventsCount) {
        diagnostics.lastEventsCount = nextEventCount;
        diagnostics.lastEventsCountChangeTsMs = nowMs;
      }
      eventCount = nextEventCount;
      eventsChip.textContent = `events: ${eventCount}`;
      statusFileEl.textContent = root.status_path || paths.status_path || '--';
      eventsFileEl.textContent = root.events_path || paths.events_path || '--';
      logFileEl.textContent = root.log_path || paths.log_path || '--';

      diagnostics.latestTracking = {
        ...tracking,
        metrics,
      };
      refreshDiagnostics();
    }

    function ingestEvent(event, options = {}) {
      const redraw = options.redraw !== false;
      const refresh = options.refresh !== false;
      const epoch = toNum(event.epoch_current, 0);
      const metrics = event.metrics || {};
      const payload = event.payload || {};
      const eventTsMs = parseTimestampMs(event.timestamp) || Date.now();
      diagnostics.lastEventTsMs = Math.max(diagnostics.lastEventTsMs, eventTsMs);

      if (event.event_type === 'case_started') {
        diagnostics.lastCaseStartedTsMs = eventTsMs;
        recordCaseTotalForEpoch(event);
      }

      if (event.event_type === 'case_completed') {
        diagnostics.lastCaseStartedTsMs = null;
        const timing = payload.timing_ms || {};
        const caseSec = toNum(timing.case_total, NaN) / 1000;
        const pipelineSec = toNum(timing.pipeline_run, NaN) / 1000;
        const gradingSec = toNum(timing.grading, NaN) / 1000;
        const phaseName = String(event.phase || '');
        if (Number.isFinite(caseSec) && caseSec > 0) {
          pushCapped(diagnostics.caseDurationsSec, caseSec);
          pushCapped(trend.runtimeCase, caseSec);
          if (phaseName) {
            if (!diagnostics.phaseCaseDurationsByPhase[phaseName]) {
              diagnostics.phaseCaseDurationsByPhase[phaseName] = [];
            }
            pushCapped(diagnostics.phaseCaseDurationsByPhase[phaseName], caseSec, 180);
          }
        }
        if (Number.isFinite(pipelineSec) && pipelineSec > 0) {
          pushCapped(diagnostics.pipelineDurationsSec, pipelineSec);
          pushCapped(trend.runtimePipeline, pipelineSec);
        }
        if (Number.isFinite(gradingSec) && gradingSec > 0) {
          pushCapped(diagnostics.gradingDurationsSec, gradingSec);
          pushCapped(trend.runtimeGrading, gradingSec);
        }
        if (metrics.latest_case_score !== undefined) {
          metricCaseEl.textContent = safeFixed(metrics.latest_case_score, 3);
        }
      }

      if (event.event_type === 'phase_completed') {
        const phase = String(event.phase || '');
        const phaseSec = toNum(event.phase_elapsed_seconds, NaN);
        if (phase && Number.isFinite(phaseSec) && phaseSec > 0) {
          if (!diagnostics.phaseDurationsByPhase[phase]) diagnostics.phaseDurationsByPhase[phase] = [];
          pushCapped(diagnostics.phaseDurationsByPhase[phase], phaseSec, 120);
          diagnostics.phaseLatestByPhase[phase] = phaseSec;
        }
      }

      if (event.event_type === 'epoch_completed') {
        const epochElapsedSec = toNum(event.elapsed_seconds, NaN);
        if (Number.isFinite(epochElapsedSec) && epochElapsedSec > 0) {
          const previousElapsedSec = toNum(diagnostics.lastEpochCompletedElapsedSec, 0);
          const epochDurationSec = Math.max(epochElapsedSec - previousElapsedSec, 0);
          if (epochDurationSec > 0) {
            pushCapped(diagnostics.epochCompletedDurationsSec, epochDurationSec, 60);
          }
          diagnostics.lastEpochCompletedElapsedSec = epochElapsedSec;
        }

        const idx = ensureEpochSlot(epoch);
        trend.scoresA[idx] = toNum(metrics.avg_score_a, trend.scoresA[idx]);
        trend.scoresB[idx] = toNum(metrics.avg_score_b, trend.scoresB[idx]);
        trend.deltas[idx] = toNum(metrics.improvement_delta, trend.deltas[idx]);
        trend.failures[idx] = toNum(metrics.num_failures_in_a, toNum(payload.num_failures_in_a, 0));
        trend.rca[idx] = toNum(metrics.num_rca_items, toNum(payload.num_rca_items, 0));
      }

      if (event.event_type === 'prompt_scoring_snapshot') {
        const idx = ensureEpochSlot(epoch);
        trend.promptAccepted[idx] = toNum(metrics.prompt_accepted_blocks, 0);
        trend.promptRejected[idx] = toNum(metrics.prompt_rejected_blocks, 0);
        trend.promptScored[idx] = toNum(metrics.prompt_scored_blocks, 0);
        const blockScores = Array.isArray(payload.block_scores) ? payload.block_scores : [];
        trend.latestPromptScores = blockScores;
        trend.latestPromptEpoch = epoch;
        renderPromptScoreTable(blockScores);
        promptScoringSubEl.textContent = `epoch ${epoch} | scored ${toNum(metrics.prompt_scored_blocks, 0)} | accepted ${toNum(metrics.prompt_accepted_blocks, 0)} | rejected ${toNum(metrics.prompt_rejected_blocks, 0)}`;
      }

      if (redraw) {
        drawAllCharts();
      }
      if (refresh) {
        refreshDiagnostics();
      }
    }

    function renderPromptScoreTable(scores) {
      promptScoreBodyEl.innerHTML = '';
      const rows = Array.isArray(scores) ? scores : [];
      if (!rows.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 6;
        td.textContent = 'No prompt scoring diagnostics yet.';
        tr.appendChild(td);
        promptScoreBodyEl.appendChild(tr);
        return;
      }

      for (const item of rows) {
        const tr = document.createElement('tr');
        const blockId = String(item.block_id || '--');
        const baseline = item.baseline_total;
        const candidate = item.candidate_total;
        const delta = item.delta_total;
        const accepted = Boolean(item.accepted);
        const reason = String(item.decision_reason || '--');

        const tdBlock = document.createElement('td');
        tdBlock.textContent = blockId;
        tr.appendChild(tdBlock);

        const tdBase = document.createElement('td');
        tdBase.textContent = baseline === null || baseline === undefined ? '--' : safeFixed(baseline, 2);
        tr.appendChild(tdBase);

        const tdCand = document.createElement('td');
        tdCand.textContent = candidate === null || candidate === undefined ? '--' : safeFixed(candidate, 2);
        tr.appendChild(tdCand);

        const tdDelta = document.createElement('td');
        const deltaNum = Number(delta);
        tdDelta.textContent = Number.isFinite(deltaNum) ? safeFixed(deltaNum, 2) : '--';
        if (Number.isFinite(deltaNum)) {
          tdDelta.className = deltaNum >= 0 ? 'delta-pos' : 'delta-neg';
        }
        tr.appendChild(tdDelta);

        const tdAccepted = document.createElement('td');
        tdAccepted.textContent = accepted ? 'yes' : 'no';
        tdAccepted.className = accepted ? 'decision-ok' : 'decision-no';
        tr.appendChild(tdAccepted);

        const tdReason = document.createElement('td');
        tdReason.textContent = reason;
        tr.appendChild(tdReason);

        promptScoreBodyEl.appendChild(tr);
      }
    }

    function drawLineChart(canvas, seriesList, yMin = null, yMax = null) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const padding = { top: 18, right: 12, bottom: 24, left: 32 };
      const plotW = width - padding.left - padding.right;
      const plotH = height - padding.top - padding.bottom;

      const allValues = [];
      for (const s of seriesList) {
        for (const value of s.data) {
          if (typeof value === 'number' && Number.isFinite(value)) allValues.push(value);
        }
      }

      if (!allValues.length) {
        ctx.fillStyle = '#8c7a60';
        ctx.font = '12px sans-serif';
        ctx.fillText('No data yet', padding.left, padding.top + 18);
        return;
      }

      const minVal = yMin !== null ? yMin : Math.min(...allValues);
      const maxVal = yMax !== null ? yMax : Math.max(...allValues);
      const span = Math.max(0.001, maxVal - minVal);
      const pointsCount = Math.max(...seriesList.map((s) => s.data.length), 1);

      ctx.strokeStyle = 'rgba(126, 102, 67, 0.24)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i += 1) {
        const y = padding.top + (plotH * i) / 4;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      function toPoint(index, value) {
        const x = padding.left + ((pointsCount <= 1 ? 0 : index / (pointsCount - 1)) * plotW);
        const y = padding.top + (1 - ((value - minVal) / span)) * plotH;
        return { x, y };
      }

      for (const series of seriesList) {
        ctx.strokeStyle = series.color;
        ctx.fillStyle = series.color;
        ctx.lineWidth = 2;
        let started = false;
        series.data.forEach((value, index) => {
          if (typeof value !== 'number' || !Number.isFinite(value)) return;
          const p = toPoint(index, value);
          if (!started) {
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            started = true;
          } else {
            ctx.lineTo(p.x, p.y);
          }
        });
        if (started) ctx.stroke();

        series.data.forEach((value, index) => {
          if (typeof value !== 'number' || !Number.isFinite(value)) return;
          const p = toPoint(index, value);
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      ctx.fillStyle = '#7b6a52';
      ctx.font = '11px sans-serif';
      ctx.fillText(`min ${safeFixed(minVal, 2)} / max ${safeFixed(maxVal, 2)}`, padding.left, height - 6);
    }

    function drawAllCharts() {
      drawLineChart(scoresChart, [
        { label: 'A', data: trend.scoresA, color: '#8d642f' },
        { label: 'B', data: trend.scoresB, color: '#3f7c4a' },
      ], 0, 10);

      drawLineChart(failuresChart, [
        { label: 'failures', data: trend.failures, color: '#ad4f4f' },
        { label: 'rca', data: trend.rca, color: '#a67222' },
      ], 0, null);

      drawLineChart(promptChart, [
        { label: 'accepted', data: trend.promptAccepted, color: '#3f7c4a' },
        { label: 'rejected', data: trend.promptRejected, color: '#ad4f4f' },
        { label: 'scored', data: trend.promptScored, color: '#8d642f' },
      ], 0, null);

      drawLineChart(runtimeChart, [
        { label: 'pipeline', data: trend.runtimePipeline, color: '#8d642f' },
        { label: 'grading', data: trend.runtimeGrading, color: '#3f7c4a' },
        { label: 'case', data: trend.runtimeCase, color: '#ad4f4f' },
      ], 0, null);
    }

    function registerEvent(event, options = {}) {
      const append = options.append !== false;
      const redraw = options.redraw !== false;
      const refresh = options.refresh !== false;
      const key = eventKey(event);
      if (seenEventKeys.has(key)) return;
      seenEventKeys.add(key);
      if (append) appendEvent(event);
      ingestEvent(event, { redraw, refresh });
    }

    async function fetchStatus() {
      try {
        const res = await fetch('/training/status');
        const data = await res.json();
        renderStatus(data);
      } catch (err) {
        setStateChip('error');
        messageEl.textContent = `Status fetch failed: ${String(err)}`;
      }
    }

    async function fetchRecentEvents() {
      try {
        const res = await fetch('/training/events?limit=2000');
        const data = await res.json();
        const events = Array.isArray(data?.events) ? data.events : [];
        eventsEl.innerHTML = '';
        eventCount = 0;
        seenEventKeys.clear();
        resetTrendState();

        for (const event of events) {
          registerEvent(event, { append: false, redraw: false, refresh: false });
        }

        const fragment = document.createDocumentFragment();
        const recent = events.slice(Math.max(0, events.length - MAX_RENDERED_EVENTS));
        for (const event of recent) {
          fragment.appendChild(createEventNode(event));
        }
        eventsEl.appendChild(fragment);
        eventsEl.scrollTop = eventsEl.scrollHeight;
        eventCount = events.length;
        eventsChip.textContent = `events: ${eventCount}`;

        drawAllCharts();
        refreshDiagnostics();
      } catch (err) {
        // Keep monitor running even if historical event read fails.
      }
    }

    function connectStream() {
      if (source) {
        source.close();
        source = null;
      }

      source = new EventSource('/training/stream?poll_ms=800');
      source.onmessage = (raw) => {
        if (!raw?.data) return;
        let event;
        try {
          event = JSON.parse(raw.data);
        } catch {
          return;
        }

        if (event.event_type === 'heartbeat') {
          renderStatus({
            tracking: {
              run_id: event.run_id,
              state: event.state,
              epoch_current: event.epoch_current,
              epochs_total: event.epochs_total,
              phase: event.phase,
              step: event.step,
              message: event.message,
              current_case: event.current_case,
              updated_at: event.timestamp,
              events_count: event.events_count || eventCount,
              elapsed_seconds: event.elapsed_seconds,
              phase_elapsed_seconds: event.phase_elapsed_seconds,
              metrics: event.metrics || {},
            },
          });
          return;
        }

        registerEvent(event, { append: true, redraw: true });
        renderStatus({
          tracking: {
            run_id: event.run_id,
            state: event.event_type === 'run_completed'
              ? 'completed'
              : (event.event_type === 'run_error' ? 'error' : 'running'),
            epoch_current: event.epoch_current,
            epochs_total: event.epochs_total,
            phase: event.phase,
            step: event.step,
            message: event.message,
            updated_at: event.timestamp,
            current_case: event.current_case,
            events_count: event.seq || eventCount,
            elapsed_seconds: event.elapsed_seconds,
            phase_elapsed_seconds: event.phase_elapsed_seconds,
            metrics: event.metrics || {},
          },
        });
      };

      source.onerror = () => {
        setStateChip('warn');
        messageEl.textContent = 'Stream disconnected. Reconnecting...';
        setTimeout(connectStream, 2000);
      };
    }

    reconnectBtn.addEventListener('click', connectStream);
    refreshBtn.addEventListener('click', async () => {
      await fetchStatus();
      await fetchRecentEvents();
    });
    clearBtn.addEventListener('click', () => {
      eventsEl.innerHTML = '';
      eventCount = 0;
      eventsChip.textContent = 'events: 0';
      seenEventKeys.clear();
      resetTrendState();
    });

    fetchStatus();
    fetchRecentEvents();
    connectStream();
    setInterval(fetchStatus, 10000);
  </script>
</body>
</html>
