import unittest\n\ndef tokenize(expr):\n    tokens = []\n    i = 0\n    while i < len(expr):\n        c = expr[i]\n        if c.isspace():\n            i += 1\n            continue\n        if c.isdigit() or c == '.':\n            j = i\n            while j < len(expr) and (expr[j].isdigit() or expr[j] == '.'):\n                j += 1\n            tokens.append(('NUMBER', expr[i:j]))\n            i = j\n        elif c in '+-*/()':\n            if c == '+':\n                tokens.append(('PLUS', c))\n            elif c == '-':\n                tokens.append(('MINUS', c))\n            elif c == '*':\n                tokens.append(('TIMES', c))\n            elif c == '/':\n                tokens.append(('DIVIDE', c))\n            elif c == '(':\n                tokens.append(('LPAREN', c))\n            elif c == ')':\n                tokens.append(('RPAREN', c))\n            i += 1\n        else:\n            raise SyntaxError('Unexpected character ' + c + ' at ' + str(i))\n    tokens.append(('EOF', ''))\n    return tokens\n\nclass PrattParser:\n    def __init__(self, tokens):\n        self.tokens = tokens\n        self.pos = 0\n    def peek(self):\n        return self.tokens[self.pos][0] if self.pos < len(self.tokens) else 'EOF'\n    def consume(self, expected_type):\n        typ, val = self.tokens[self.pos]\n        if typ != expected_type:\n            raise SyntaxError('Expected ' + expected_type + ' but got ' + typ)\n        self.pos += 1\n        return val\n    def parse_expression(self, min_prec):\n        token_type, value = self.tokens[self.pos]\n        if token_type == 'NUMBER':\n            left = float(value)\n            self.consume('NUMBER')\n        elif token_type == 'LPAREN':\n            self.consume('LPAREN')\n            left = self.parse_expression(0)\n            self.consume('RPAREN')\n        else:\n            raise SyntaxError('Expected number or "("')\n        while self.peek() in ('PLUS','MINUS','TIMES','DIVIDE'):\n            op_type = self.peek()\n            op_prec = PRECEDENCE[op_type]\n            if op_prec < min_prec:\n                break\n            self.consume(op_type)\n            right = self.parse_expression(op_prec + 1)\n            if op_type == 'PLUS':\n                left += right\n            elif op_type == 'MINUS':\n                left -= right\n            elif op_type == 'TIMES':\n                left *= right\n            elif op_type == 'DIVIDE':\n                left /= right\n        return left\n    def parse(self):\n        return self.parse_expression(0)\n\nPRECEDENCE = {\n    'TIMES': 2,\n    'DIVIDE': 2,\n    'PLUS': 1,\n    'MINUS': 1,\n}\n\ndef evaluate(expr):\n    tokens = tokenize(expr)\n    parser = PrattParser(tokens)\n    return parser.parse()\n\nclass TestPrattParser(unittest.TestCase):\n    def test_simple(self):\n        self.assertEqual(evaluate('2+3'), 5)\n    def test_precedence(self):\n        self.assertEqual(evaluate('2+3*4'), 14)\n    def test_parentheses(self):\n        self.assertEqual(evaluate('(2+3)*4'), 20)\n    def test_negative(self):\n        self.assertEqual(evaluate('-2'), -2)\n    def test_division(self):\n        self.assertAlmostEqual(evaluate('8/3'), 8/3)\n\n# Run tests\nTestPrattParser().test_simple()\nTestPrattParser().test_precedence()\nTestPrattParser().test_parentheses()\nTestPrattParser().test_negative()\nTestPrattParser().test_division()\n\n# Compute final result\nresult = evaluate('2+3*4')\nprint(result)\n