import pandas as pd\nimport statsmodels.api as sm\nfrom scipy.spatial.distance import cdist\n\n# Assume df_wage and df_emp are provided with columns 'treated', 'age', 'education', 'experience'\n# (these DataFrames should already exist in the environment)\nimport pandas as pd\nimport statsmodels.api as sm\nfrom scipy.spatial.distance import cdist\n\n# Combine datasets\ndf = pd.concat([df_wage, df_emp], ignore_index=True)\n\ncovariates = ['age', 'education', 'experience']\nX = sm.add_constant(df[covariates])\ny = df['treated']\npropensity_model = sm.Logit(y, X).fit(disp=False)\ndf['propensity'] = propensity_model.predict(X)\n\n# Nearest neighbor matching (1:1 without replacement)\nmatches = []\ntreated_idx = df[df['treated']==1].index\ncontrol_idx = df[df['treated']==0].index\nfor t_idx in treated_idx:\n    t_prop = df.loc[t_idx, 'propensity']\n    dists = cdist([t_prop], df.loc[control_idx, 'propensity'].values.reshape(-1,1), metric='euclidean')\n    nearest_ctrl = control_idx[dists.argmin()]\n    matches.append((t_idx, nearest_ctrl))\n\nmatched_indices = [i for pair in matches for i in pair]\nmatched_df = df.loc[matched_indices].copy()\nmatched_df['match_id'] = (matched_df.index // 2)\n\n# Balance diagnostics: standardized mean differences\ndef std_mean_diff(tr, co):\n    diff = tr.mean() - co.mean()\n    pooled_std = ((tr.var() + co.var()) / 2) ** 0.5\n    return diff / pooled_std\n\nsmds = {}\nfor var in covariates:\n    treated_vals = matched_df.loc[matched_df['treated']==1, var]\n    control_vals = matched_df.loc[matched_df['treated']==0, var]\n    smds[var] = std_mean_diff(treated_vals, control_vals)\n\n# Final result\nresult = {\n    'matched_rows': len(matched_df),\n    'average_smd': sum(smds.values()) / len(smds) if smds else 0,\n    'smd_by_covariate': smds\n}\nprint(result)\n