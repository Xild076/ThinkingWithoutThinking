import pandas as pd\nimport statsmodels.api as sm\nfrom scipy.spatial.distance import cdist\n\n# Create synthetic datasets\n df_wage = pd.DataFrame({\n     'treated': [1,0,1,0,1],\n     'age': [30,45,35,40,28],\n     'education': [16,14,16,15,17],\n     'experience': [10,15,8,12,5]\n })\n df_emp = pd.DataFrame({\n     'treated': [0,1,0,1,0],\n     'age': [50,38,42,33,45],\n     'education': [12,16,13,15,14],\n     'experience': [20,10,18,8,22]\n })\n\n# Combine datasets\n df = pd.concat([df_wage, df_emp], ignore_index=True)\n\n# Covariates for propensity model\n covariates = ['age', 'education', 'experience']\n X = sm.add_constant(df[covariates])\n y = df['treated']\n # Fit logistic regression\n propensity_model = sm.Logit(y, X, missing='drop').fit(disp=False)\n df['propensity'] = propensity_model.predict(X)\n\n# Separate treated and control\n treated = df[df['treated'] == 1]\n control = df[df['treated'] == 0]\n\n# Nearest neighbor matching on propensity\n matches = []\n for _, t_row in treated.iterrows():\n     t_prop = t_row['propensity']\n     dists = cdist([[t_prop]], control[['propensity']].values, metric='euclidean')\n     nearest_idx = dists.argmin()\n     matches.append((t_row.name, control.index[nearest_idx]))\n\n# Get matched indices\n matched_indices = [i for pair in matches for i in pair]\n matched_df = df.loc[matched_indices].copy()\n matched_df['match_id'] = (matched_df.index // 2)  # simple grouping\n\n# Balance diagnostics: standardized mean differences\n def std_mean_diff(tr, co):\n     diff = tr.mean() - co.mean()\n     pooled_std = ((tr.var() + co.var()) / 2) ** 0.5\n     return diff / pooled_std\n\n smds = {}\n for var in covariates:\n     tr_vals = matched_df.loc[matched_df['treated']==1, var]\n     co_vals = matched_df.loc[matched_df['treated']==0, var]\n     smds[var] = std_mean_diff(tr_vals, co_vals)\n\n# Final result\n result = {\n     'matched_rows': len(matched_df),\n     'average_smd': sum(smds.values()) / len(smds) if smds else 0,\n     'smd_by_covariate': smds\n }\n print(result)\n